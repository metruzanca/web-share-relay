/// <reference lib="webworker" />
import { precacheAndRoute } from 'workbox-precaching';

declare let self: ServiceWorkerGlobalScope;

// Precache all assets generated by the build process
precacheAndRoute(self.__WB_MANIFEST);

const SHARE_TARGET_STORE = 'share-target-store';

// Handle share target POST requests
self.addEventListener('fetch', (event) => {
  const url = new URL(event.request.url);
  
  // Intercept POST requests to /share-target
  if (url.pathname === '/share-target' && event.request.method === 'POST') {
    event.respondWith(handleShareTarget(event.request));
  }
});

async function handleShareTarget(request: Request): Promise<Response> {
  try {
    const formData = await request.formData();
    
    // Extract shared data
    const title = (formData.get('title') as string) || '';
    const text = (formData.get('text') as string) || '';
    const url = (formData.get('url') as string) || '';
    const files = formData.getAll('files');
    
    // Process files to serializable format
    const processedFiles: Array<{ name: string; type: string; data: string }> = [];
    for (const file of files) {
      if (file instanceof File && file.size > 0) {
        const arrayBuffer = await file.arrayBuffer();
        const base64 = arrayBufferToBase64(arrayBuffer);
        processedFiles.push({
          name: file.name,
          type: file.type,
          data: base64,
        });
      }
    }
    
    // Store the shared data in IndexedDB for the app to retrieve
    const shareData = {
      title,
      text,
      url,
      files: processedFiles,
      timestamp: Date.now(),
    };
    
    await storeShareData(shareData);
    
    // Redirect to the app with a flag to indicate pending share data
    return Response.redirect('/?share-target=pending', 303);
  } catch (error) {
    console.error('Error handling share target:', error);
    return Response.redirect('/?share-target=error', 303);
  }
}

function arrayBufferToBase64(buffer: ArrayBuffer): string {
  let binary = '';
  const bytes = new Uint8Array(buffer);
  for (let i = 0; i < bytes.byteLength; i++) {
    binary += String.fromCharCode(bytes[i]);
  }
  return btoa(binary);
}

async function storeShareData(data: unknown): Promise<void> {
  const db = await openShareDB();
  const tx = db.transaction(SHARE_TARGET_STORE, 'readwrite');
  const store = tx.objectStore(SHARE_TARGET_STORE);
  store.put(data, 'pending');
}

function openShareDB(): Promise<IDBDatabase> {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open('share-target-db', 1);
    
    request.onerror = () => reject(request.error);
    request.onsuccess = () => resolve(request.result);
    
    request.onupgradeneeded = (event) => {
      const db = (event.target as IDBOpenDBRequest).result;
      if (!db.objectStoreNames.contains(SHARE_TARGET_STORE)) {
        db.createObjectStore(SHARE_TARGET_STORE);
      }
    };
  });
}
